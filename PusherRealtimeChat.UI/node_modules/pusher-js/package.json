{
  "name": "pusher-js",
  "version": "3.2.1",
  "description": "Pusher JavaScript library for browser, React Native, NodeJS and web workers",
  "main": "dist/web/pusher.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/pusher-community/pusher-websocket-js-iso.git"
  },
  "keywords": [
    "pusher",
    "client",
    "websocket",
    "http",
    "fallback",
    "isomorphic",
    "events",
    "pubsub"
  ],
  "author": {
    "name": "Pusher"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/pusher-community/pusher-websocket-js-iso/issues"
  },
  "homepage": "https://github.com/pusher-community/pusher-websocket-js-iso",
  "devDependencies": {
    "es3ify-loader": "^0.2.0",
    "fetch-mock": "git+https://git@github.com/jpatel531/fetch-mock.git",
    "isomorphic-fetch": "^2.2.1",
    "jasmine-node": "^1.14.5",
    "jasmine-spec-reporter": "^1.2.0",
    "jshint": "~2.6.3",
    "karma": "^0.13.18",
    "karma-browserstack-launcher": "^0.1.11",
    "karma-chrome-launcher": "^0.1.7",
    "karma-coverage": "^0.2.7",
    "karma-firefox-launcher": "^0.1.4",
    "karma-jasmine": "~0.1.0",
    "karma-jasmine-web-worker": "^0.1.2",
    "karma-opera-launcher": "^0.1.0",
    "karma-safari-launcher": "^0.1.1",
    "karma-spec-reporter": "0.0.24",
    "karma-verbose-reporter": "0.0.3",
    "karma-webpack": "^1.7.0",
    "object-assign-deep": "0.0.4",
    "string-replace-webpack-plugin": "0.0.3",
    "ts-loader": "^0.8.2",
    "typescript": "^1.8.0",
    "uglify-js": "^2.6.2",
    "webpack": "^1.12.9",
    "webpack-dev-server": "^1.14.1"
  },
  "dependencies": {
    "faye-websocket": "0.9.4",
    "xmlhttprequest": "^1.8.0"
  },
  "readme": "# Pusher Javascript Client\n\nThis library is an open source client that allows Javascript web browser clients to connect to the [Pusher](http://pusher.com/) WebSocket API. It also supports fallback to HTTP connection transports. It is highly recommended that you use the hosted version of this file to stay up to date with the latest updates.\n\nWe have included the source code for following libraries:\n\n* sockjs-client\n\nThey both include their own licences.\n\n## Usage overview\n\nThe following topics are covered:\n\n* Supported runtimes and installation\n  * Web\n  * React Native\n  * Web Workers\n  * NodeJS\n* Configuration\n* Global configuration\n* Connection\n* Socket ids\n* Subscribing to channels (public and private)\n* Binding to events\n  * Globally\n  * Per-channel\n* Default events\n\n## Installation\n\n### Web\n\nIf you're using PusherJS on a web page, you can install the library via:\n\n#### CDN\n\n```html\n<script src=\"//js.pusher.com/3.1/pusher.min.js\"></script>\n```\n\n#### Bower\n\nOr via [Bower](http://bower.io/):\n\n```bash\nbower install pusher\n```\n\nand then\n\n```html\n<script src=\"bower_components/pusher/dist/web/pusher.min.js\"></script>\n```\n\n#### NPM\n\n```bash\nnpm install pusher-js\n```\n\nThen simply call:\n\n```javascript\nvar Pusher = require('pusher-js');\n```\n\n### React Native\n\nYou can install `pusher-js` from NPM, then import the `react-native` path of PusherJS.\n\n```javascript\nimport Pusher from 'pusher-js/react-native';\n```\n\nNotes:\n\n* The fallbacks available for this runtime are HTTP streaming and polling.\n* This build uses React Native's NetInfo API to detect changes on connectivity state. It will use this to automatically reconnect.\n\n### Web Workers\n\nYou can import the worker script (`pusher.worker.js`, not `pusher.js`) from the CDN:\n\n```javascript\nimportScripts(\"https://js.pusher.com/3.1/pusher.worker.min.js\");\n```\n\n### NodeJS\n\nHaving installed `pusher-js` via NPM, simply call:\n\n```javascript\nvar Pusher = require('pusher-js/node');\n```\n\nNotes:\n\n* For standard `WebWorkers`, this build will use HTTP as a fallback.\n* For `ServiceWorkers`, as the `XMLHttpRequest` API is unavailable, there is currently no support for HTTP fallbacks. However, we are open to requests for fallbacks using `fetch` if there is demand.\n\n## Initialization\n\n```js\nvar pusher = new Pusher(APP_KEY);\n```\n\n## Configuration\n\nThere are a number of configuration parameters which can be set for the Pusher client, which can be passed as an object to the Pusher constructor, i.e.:\n\n```js\nvar pusher = new Pusher(APP_KEY, {\n    authEndpoint: \"http://example.com/pusher/auth\",\n    encrypted: true\n});\n```\n\nFor most users, there is little need to change these. See [client API guide](http://pusher.com/docs/client_api_guide/client_connect) for more details.\n\n#### `encrypted` (Boolean)\n\nForces the connection to use encrypted transports.\n\n#### `authEndpoint` (String)\n\nEndpoint on your server that will return the authentication signature needed for private channels.\n\n#### `authTransport` (String)\n\nDefines how the authentication endpoint, defined using authEndpoint, will be called. There are two options available: `ajax` and `jsonp`.\n\n#### `auth` (Hash)\n\nAllows passing additional data to authorizers. Supports query string params and headers (AJAX only). For example, following will pass `foo=bar` via the query string and `baz: boo` via headers:\n\n```js\nvar pusher = new Pusher(API_KEY, {\n  auth: {\n    params: { foo: \"bar\" },\n    headers: { baz: \"boo\" }\n  }\n});\n```\n\n##### CSRF\n\nIf you require a CSRF header for incoming requests to the private channel authentication endpoint on your server, you should add a CSRF token to the `auth` hash under `headers`. This is applicable to frameworks which apply CSRF protection by default.\n\n```js\nvar pusher = new Pusher(API_KEY, {\n  auth: {\n    params: { foo: \"bar\" },\n    headers: { \"X-CSRF-Token\": \"SOME_CSRF_TOKEN\" }\n  }\n});\n```\n\n#### `cluster` (String)\n\nAllows connecting to a different datacenter by setting up correct hostnames and ports for the connection.\n\n```js\n// will connect to the 'eu' cluster\nvar pusher = new Pusher(API_KEY, { cluster: \"eu\" });\n```\n\n#### `disableStats` (Boolean)\n\nDisables stats collection, so that connection metrics are not submitted to Pusherâ€™s servers.\n\n#### `enabledTransports` (Array)\n\nSpecifies which transports should be used by Pusher to establish a connection. Useful for applications running in controlled, well-behaving environments. Available transports for web: `ws`, `wss`, `xhr_streaming`, `xhr_polling`, `sockjs`. Additional transports may be added in the future and without adding them to this list, they will be disabled.\n\n```js\n// will only use WebSockets\nvar pusher = new Pusher(API_KEY, { enabledTransports: [\"ws\"] });\n```\n\n#### `disabledTransports` (Array)\n\nSpecified which transports must not be used by Pusher to establish a connection. This settings overwrites transports whitelisted via the `enabledTransports` options. Available transports for web: `ws`, `wss`, `xhr_streaming`, `xhr_polling`, `sockjs`. Additional transports may be added in the future and without adding them to this list, they will be enabled.\n\n```js\n// will use all transports except for sockjs\nvar pusher = new Pusher(API_KEY, { disabledTransports: [\"sockjs\"] });\n\n// will only use WebSockets\nvar pusher = new Pusher(API_KEY, {\n  enabledTransports: [\"ws\", \"xhr_streaming\"],\n  disabledTransports: [\"xhr_streaming\"]\n});\n```\n\n#### `wsHost`, `wsPort`, `wssPort`, `httpHost`, `httpPort`, `httpsPort`\n\nThese can be changed to point to alternative Pusher URLs (used internally for our staging server).\n\n#### `ignoreNullOrigin` (Boolean)\n\nIgnores null origin checks for HTTP fallbacks. Use with care, it should be disabled only if necessary (i.e. PhoneGap).\n\n#### `activityTimeout` (Integer)\n\nAfter this time (in miliseconds) without any messages received from the server, a ping message will be sent to check if the connection is still working. Default value is is supplied by the server, low values will result in unnecessary traffic.\n\n#### `pongTimeout` (Integer)\n\nTime before the connection is terminated after sending a ping message. Default is 30000 (30s). Low values will cause false disconnections, if latency is high.\n\n## Global configuration\n\n### `Pusher.logToConsole` (Boolean)\n\nEnables logging to the browser console via calls to `console.log`.\n\n### `Pusher.log` (Function)\n\nAssign a custom log handler for the Pusher library logging. For example:\n\n```js\nPusher.log = function(msg) {\n  console.log(msg);\n};\n```\n\nBy setting the `log` property you also override the use of `Pusher.enableLogging`.\n\n## Connection\n\nA connection to Pusher is established by providing your API key to the constructor function:\n\n```js\nvar socket = new Pusher(API_KEY);\n```\n\nThis returns a socket object which can then be used to subscribe to channels.\n\n### Socket IDs\n\nMaking a connection provides the client with a new `socket_id` that is assigned by the server. This can be used to distinguish the client's own events. A change of state might otherwise be duplicated in the client. More information on this pattern is available [here](http://pusherapp.com/docs/duplicates).\n\nIt is also stored within the socket, and used as a token for generating signatures for private channels.\n\n## Subscribing to channels\n\n### Public channels\n\nThe default method for subscribing to a channel involves invoking the `subscribe` method of your socket object:\n\n```js\nvar my_channel = socket.subscribe('my-channel');\n```\n\nThis returns a Channel object which events can be bound to.\n\n### Private channels\n\nPrivate channels are created in exactly the same way as normal channels, except that they reside in the 'private-' namespace. This means prefixing the channel name:\n\n```js\nvar my_channel = socket.subscribe('private-my-channel');\n```\n\nIt is possible to access channels by name, through the `channel` function:\n\n```js\nchannel = socket.channel('private-my-channel');\n```\n\nIt is possible to access all subscribed channels through the `allChannels` function:\n\n```js\nvar channels = socket.allChannels();\nconsole.group('Pusher - subscribed to:');\nfor (var i = 0; i < channels.length; i++) {\n    var channel = channels[i];\n    console.log(channel.name);\n}\n\nconsole.groupEnd();\n```\n\nPrivate and presence channels will make a request to your `authEndpoint` (`/pusher/auth`) by default, where you will have to [authenticate the subscription](https://pusher.com/docs/authenticating_users). You will have to send back the correct auth response and a 200 status code.\n\n## Unsubscribing from channels\n\nTo unsubscribe from a channel, invoke the `unsubscribe` method of your socket object:\n\n```js\nsocket.unsubscribe('my-channel');\n```\n\nUnsubscribing from private channels is done in exactly the same way, just with the additional `private-` prefix:\n\n```js\nsocket.unsubscribe('private-my-channel');\n```\n\n## Binding to events\n\nEvents can be bound to at 2 levels, the global, and per channel. They take a very similar form to the way events are handled in jQuery.\n\n### Global events\n\nYou can attach behaviour to these events regardless of the channel the event is broadcast to. The following is an example of an app that binds to new comments from any channel:\n\n```js\nvar socket = new Pusher('MY_API_KEY');\nvar my_channel = socket.subscribe('my-channel');\nsocket.bind('new-comment',\n  function(data) {\n    // add comment into page\n  }\n);\n```\n\n### Per-channel events\n\nThese are bound to a specific channel, and mean that you can reuse event names in different parts of your client application. The following might be an example of a stock tracking app where several channels are opened for different companies:\n\n```js\nvar socket = new Pusher('MY_API_KEY');\nvar channel = socket.subscribe('APPL');\nchannel.bind('new-price',\n  function(data) {\n    // add new price into the APPL widget\n  }\n);\n```\n\n### Bind event handler with optional context\n\nIt is possible to provide a third, optional parameter that is used as the `this` value when calling a handler:\n\n```js\nvar context = { title: 'Pusher' };\nvar handler = function(){\n  console.log('My name is ' + this.title);\n};\nchannel.bind('new-comment', handler, context);\n```\n\n### Unbind event handlers\n\nRemove previously-bound handlers from an object. Only handlers that match all of the provided arguments (`eventName`, `handler` or `context`) are removed:\n\n```js\nchannel.unbind('new-comment', handler); // removes just `handler` for the `new-comment` event\nchannel.unbind('new-comment'); // removes all handlers for the `new-comment` event\nchannel.unbind(null, handler); // removes `handler` for all events\nchannel.unbind(null, null, context); // removes all handlers for `context`\nchannel.unbind(); // removes all handlers on `channel`\n```\n\n### Binding to everything\n\nIt is possible to bind to all events, rather than specifying the event name, using the method `bind_all`. This can be used for debugging, but may have other utilities.\n\nThis binding can be done for a single channel or for all subscribed channels. Here is how to bind to all events on a single channel:\n\n```javascript\nvar channel = pusher.subscribe('test_channel');\nchannel.bind_all(function(eventName, data) {\n  console.log(\"Received event on channel test_channel event with name\", eventName, \"and data\", data);\n});\n```\n\nTo bind to all events on all subscribed channels, instead call `pusher.bind_all`:\n\n```javascript\npusher.bind_all(function(eventName, data) {\n  console.log(\"Received event with name\", eventName, \"and data\", data);\n});\n```\n\n(Note that this will only work if the event is sent on a subscribed channel. Also note that this does not tell your callback which subscribed channel the event was sent on.)\n\n\n## Batching auth requests (aka multi-auth)\n\nCurrently, pusher-js itself does not support authenticating multiple channels in one HTTP request. However, thanks to @dirkbonhomme you can use the [pusher-js-auth](https://github.com/dirkbonhomme/pusher-js-auth) plugin that buffers subscription requests and sends auth requests to your endpoint in batches.\n\n## Default events\n\nThere are a number of events which are used internally, but can also be of use elsewhere:\n\n* connection_established\n* subscribe\n\n## Self-serving JS files\n\nYou can host JavaScript files yourself, but it's a bit more complicated than putting them somewhere and just linking `pusher.js` in the source of your website. Because pusher-js loads fallback files dynamically, the dependency loader must be configured correctly or it will be using `js.pusher.com`.\n\nFirst, clone this repository and run `npm install && git submodule init && git submodule update`. Then run:\n\n    $ CDN_HTTP='http://your.http.url' CDN_HTTPS='https://your.https.url' make web\n\nIn the `dist/web` folder, you should see the files you need: `pusher.js`, `pusher.min.js`, `json2.js`, `json.min.js`, `sockjs.js` and `sockjs.min.js`. `pusher.js` should be built referencing your URLs as the dependency hosts.\n\nFirst, make sure you expose all files from the `dist` directory. They need to be in a directory with named after the version number. For example, if you're hosting version 3.1.0 under `http://example.com/pusher-js` (and https for SSL), files should be accessible under following URL's:\n\n    http://example.com/pusher-js/3.1.0/pusher.js\n    http://example.com/pusher-js/3.1.0/json2.js\n    http://example.com/pusher-js/3.1.0/sockjs.js\n\nMinified files should have `.min` in their names, as in the `dist/web` directory:\n\n    http://example.com/pusher-js/2.1.3/pusher.min.js\n    http://example.com/pusher-js/2.1.3/json2.min.js\n    http://example.com/pusher-js/2.1.3/sockjs.min.js\n\n## SockJS compatibility\n\nMost browsers have a limit of 6 simultaneous connections to a single domain, but Internet Explorer 6 and 7 have a limit of just 2. This means that you can only use a single Pusher connection in these browsers, because SockJS requires an HTTP connection for incoming data and another one for sending. Opening the second connection will break the first one as the client won't be able to respond to ping messages and get disconnected eventually.\n\nAll other browsers work fine with two or three connections.\n\n## Developing\n\nInstall all dependencies via NPM:\n\n```bash\nnpm install\n```\n\nRun a development server which serves bundled javascript from <http://localhost:5555/pusher.js> so that you can edit files in /src freely.\n\n```bash\nmake serve\n```\n\nYou can optionally pass a `PORT` environment variable to run the server on a different port. You can also pass `CDN_HTTP` and `CDN_HTTPS` variables if you wish the library to load dependencies from a new host.\n\nThis command will serve `pusher.js`, `sockjs.js`, `json2.js`, and their respective minified versions.\n\n## Core Vs. Platform-Specific Code\n\nNew to PusherJS 3.1 is the ability for the library to produce builds for different runtimes: classic web, React Native, NodeJS and\nWeb Workers.\n\nIn order for this to happen, we have split the library into two directories: `core/` and `runtimes/`. In `core` we keep anything that is platform-independent. In `runtimes` we keep code that depends on certain runtimes.\n\nThroughout the `core/` directory you'll find this line:\n\n```javascript\nimport Runtime from \"runtime\";\n```\n\nWe use webpack module resolution to make the library look for different versions of this module depending on the build.\n\nFor web it will look for `src/runtimes/web/runtime.ts`. For ReactNative, `src/runtimes/react-native/runtime.ts`. For Node:  `src/runtimes/node/runtime.ts`. For worker: `src/runtimes/worker/runtime.ts`.\n\nEach of these runtime files exports an object (conforming to the interface you can see in `src/runtimes/interface.ts`) that abstracts away everything platform-specific. The core library pulls this object in without any knowledge of how it implements it. This means web build can use the DOM underneath, the ReactNative build can use its native NetInfo API, Workers can use `fetch` and so on.\n\n## Building\n\nIn order to build SockJS, you must first initialize and update the Git submodule:\n\n```bash\ngit submodule init\ngit submodule update\n```\n\nThen simply run:\n\n```bash\nmake web\n```\n\nThis will build the source files relevant for the web build into `dist/web`.\n\nIn order to specify the library version, you can either update `package.json` or pass a `VERSION` environment variable upon building.\n\nOther build commands include:\n\n```bash\nmake react-native # for the React Native build\nmake node         # for the NodeJS build\nmake worker       # for the worker build\n```\n\n## Testing\n\nEach test environment contains two types of tests:\n\n1. unit tests,\n2. integration tests.\n\nUnit tests are simple, fast and don't need any external dependencies. Integration tests usually connect to production and js-integration-api servers and can use a local server for loading JS files, so they need an Internet connection to work.\n\nThere are 3 different testing environments: one for web, one for NodeJS and one for workers. We may consider adding another one for React Native in the future.\n\nThe web and worker tests use [Karma](https://github.com/karma-runner/karma) to execute specs in real browsers. The NodeJS tests use [jasmine-node](https://github.com/mhevery/jasmine-node).\n\nTo run the tests:\n\n```bash\n# For web\nmake web_unit\nmake web_integration\n\n# For NodeJS\nmake node_unit\nmake node_integration\n\n# For workers\nmake worker_unit\nmake worker_integration\n```\n\nIf you want your Karma tests to automatically reload, then in `spec/karma/config.common.js` set `singleRun` to `false`.\n",
  "readmeFilename": "README.markdown",
  "_id": "pusher-js@3.2.1",
  "_shasum": "46a30800c263e837081cf7084f0a7eee55973e60",
  "_from": "pusher-js@3.2.1",
  "_resolved": "https://registry.npmjs.org/pusher-js/-/pusher-js-3.2.1.tgz"
}
